/*
 * Wazuh vulnerability scanner - Policy Manager
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _POLICY_MANAGER_HPP
#define _POLICY_MANAGER_HPP

#include "observer.hpp"
#include "routerSubscriber.hpp"
#include "singleton.hpp"
#include "stringHelper.h"
#include <external/nlohmann/json.hpp>
#include <functional>
#include <memory>
#include <string>
#include <unordered_set>
#include <vector>

constexpr auto UNKNOWN_VALUE {" "};

/**
 * @brief PolicyManager class.
 *
 */
class PolicyManager final : public Singleton<PolicyManager>
{
private:
    Subject<nlohmann::json&> m_subject;
    nlohmann::json m_configuration;
    std::unique_ptr<RouterSubscriber> m_policyChangeSubscription;
    bool m_vulDetectEnabled {true};
    bool m_indexerEnabled {true};
    bool m_vulDetectValid {true};
    bool m_indexerValid {true};
    long m_feedUpdateTime {300};
    std::string m_urlFeed {UNKNOWN_VALUE};
    std::unordered_set<std::string> m_hostList;
    std::unordered_set<std::string> m_caList;
    std::string m_username {UNKNOWN_VALUE};
    std::string m_password {UNKNOWN_VALUE};
    std::string m_certificate {UNKNOWN_VALUE};
    std::string m_key {UNKNOWN_VALUE};
    std::string m_apikey {UNKNOWN_VALUE};

    // TODO: Remove LCOV flags and add tests once the implementation of this class is completed
    // LCOV_EXCL_START
    void setDefaultPolicy()
    {
        // Set default policy
        if (!m_configuration.contains("updater"))
        {
            m_configuration["updater"] = nlohmann::json::object();
            m_configuration["updater"]["interval"] = 10 * 60;
            m_configuration["updater"]["ondemand"] = true;
            m_configuration["updater"]["topicName"] = "vulnerability_scanner_updater";
            m_configuration["updater"]["configData"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["contentSource"] = "api";
            m_configuration["updater"]["configData"]["compressionType"] = "raw";
            m_configuration["updater"]["configData"]["versionedContent"] = "false";
            m_configuration["updater"]["configData"]["deleteDownloadedContent"] = false;
            m_configuration["updater"]["configData"]["url"] = "https://swapi.dev/api/people/1";
            m_configuration["updater"]["configData"]["outputFolder"] = "";
            m_configuration["updater"]["configData"]["dataFormat"] = "json";
            m_configuration["updater"]["configData"]["fileName"] = "api_file.json";
            m_configuration["updater"]["configData"]["apiParameters"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["apiParameters"]["itemsPerRequest"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["apiParameters"]["itemsPerRequest"]["name"] = "limit";
            m_configuration["updater"]["configData"]["apiParameters"]["itemsPerRequest"]["value"] = 100;
            m_configuration["updater"]["configData"]["apiParameters"]["offset"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["apiParameters"]["offset"]["name"] = "offset";
            m_configuration["updater"]["configData"]["apiParameters"]["offset"]["step"] = 100;
            m_configuration["updater"]["configData"]["apiParameters"]["offset"]["start"] = 0;
        }

        if (!m_configuration.contains("exclusions"))
        {
            m_configuration["exclusions"] = nlohmann::json::object();
            m_configuration["exclusions"]["packages"] = nlohmann::json::array();
        }

        if (!m_configuration.contains("indexer"))
        {
            m_configuration["indexer"] = nlohmann::json::object();
            m_configuration["indexer"]["servers"] = nlohmann::json::array();
            m_configuration["indexer"]["servers"].push_back("http://localhost:9200");
            m_configuration["indexer"]["databasePath"] = "queue/indexer_vd";
        }
    }
    // LCOV_EXCL_STOP

    void call(nlohmann::json& data)
    {
        m_subject.setData(data);
    }

public:
    /**
     * @brief Initializes manager.
     *
     * @param configuration Manager configuration.
     */
    void initialize(const nlohmann::json& configuration)
    {
        loadConfiguration(configuration);

        // Validate JSON
        validateConfiguration();

        // Subscription to policy change events.
        m_policyChangeSubscription = std::make_unique<RouterSubscriber>("policy", "vulnerability_scanner");
        m_policyChangeSubscription->subscribe(
            [this](const std::vector<char>& message)
            {
                m_configuration = nlohmann::json::parse(message);
                setDefaultPolicy();
                call(m_configuration);
            });
    }

    /**
     * @brief Loads configuration settings from a JSON object.
     *
     * This function takes a JSON object containing configuration settings and
     * processes them for use by the policy manager's module.
     *
     * @param configuration The JSON object containing configuration settings.
     */
    void loadConfiguration(const nlohmann::json& configuration)
    {
        m_configuration = configuration;
    }

    /**
     * @brief Validates the configuration settings of the vulnerability-detection's module.
     *
     * This function checks if the configuration settings are valid and conform
     * to the expected format and values. It throw an exception
     * if some value in the configuration is invalid.
     *
     * @throws std::runtime If some configuration is invalid.
     *
     */

    void validateConfiguration()
    {
        if (m_configuration.contains("vulnerability-detection") && m_configuration.contains("indexer"))
        {
            validateAndConfigureVulnerabilityDetection(getVulnerabilityDetection());
            validateAndConfigureIndexer(getIndexerConfiguration());
        }
        else
        {
            throw std::runtime_error("Invalid JSON object.");
        }
    }

    /**
     * @brief Validates and configures the vulnerability detection based on the provided JSON object.
     *
     * This function takes a JSON object as input, which is expected to contain configuration
     * information for vulnerability detection. It validates the JSON object to ensure it contains the
     * required fields and has valid values. If the validation passes, no exception is thrown.
     *
     * @param vdObj A constant reference to a JSON object representing the vulnerability detection's configuration.
     *
     * @note This function assumes that the provided JSON object follows a specific format.
     * @note If validation fails, this function throws std::runtime exception.
     */

    void validateAndConfigureVulnerabilityDetection(const nlohmann::json& vdObj)
    {
        bool isValidUrl {false};

        if (!vdObj.contains("enabled"))
        {
            throw std::runtime_error("Missing enabled field.");
        }

        if (!vdObj.contains("index-status"))
        {
            throw std::runtime_error("Missing index-status field.");
        }

        if (vdObj.contains("feed-update-interval"))
        {
            if (Utils::parseStrToTime(vdObj["feed-update-interval"]) != -1)
            {
                m_feedUpdateTime = Utils::parseStrToTime(vdObj["feed-update-interval"]);
            }
        }

        if (vdObj.contains("offline-url"))
        {
            isValidUrl = Utils::startsWith(vdObj["offline-url"], "file") ||
                         Utils::startsWith(vdObj["offline-url"], "http") ||
                         Utils::startsWith(vdObj["offline-url"], "https");
        }

        try
        {
            m_vulDetectEnabled = m_vulDetectEnabled && Utils::parseStrToBool(vdObj["enabled"]);

            m_indexerEnabled = m_indexerEnabled && Utils::parseStrToBool(vdObj["index-status"]);
        }
        catch (const std::exception& e)
        {
            m_vulDetectEnabled = false;
            m_indexerEnabled = false;
            throw std::runtime_error("Invalid format argument.");
        }

        if (isValidUrl)
        {
            m_urlFeed = std::move(vdObj["offline-url"]);
        }
    }

    /**
     * @brief Validates and configures the indexer based on the provided JSON object.
     *
     * This function takes a JSON object as input, which is expected to contain configuration
     * information for the indexer. It validates the JSON object to ensure it contains the
     * required fields and has valid values, based on the previous configuration of the vulnerability detection.
     * If the validation passes, no exception is thrown.
     *
     * @param idObj A constant reference to a JSON object representing the indexer's configuration.
     *
     * @note This function assumes that the provided JSON object follows a specific format.
     * @note If validation fails, this function throws std::runtime exception.
     */

    void validateAndConfigureIndexer(const nlohmann::json& idObj)
    {
        if (!idObj.contains("enabled"))
        {
            throw std::runtime_error("Missing enabled field.");
        }

        if (!(Utils::parseStrToBool(idObj["enabled"]) && m_indexerEnabled))
        {
            throw std::runtime_error("Invalid configuration.");
        }

        if (idObj.contains("hosts"))
        {
            m_hostList = idObj["hosts"].get<std::unordered_set<std::string>>();
        }

        if (idObj.contains("username"))
        {
            m_username = std::move(idObj["username"]);
        }

        if (idObj.contains("password"))
        {
            m_password = std::move(idObj["password"]);
        }

        if (idObj.contains("api_key"))
        {
            m_apikey = std::move(idObj["api_key"]);
        }

        if (idObj.contains("ssl") && idObj["ssl"].contains("certificate_authorities"))
        {
            m_caList = idObj["ssl"]["certificate_authorities"].get<std::unordered_set<std::string>>();
        }

        if (idObj.contains("ssl") && idObj["ssl"].contains("certificate"))
        {
            m_certificate = std::move(idObj["ssl"]["certificate"]);
        }

        if (idObj.contains("ssl") && idObj["ssl"].contains("key"))
        {
            m_key = std::move(idObj["ssl"]["key"]);
        }
    }

    /**
     * @brief Adds subscriber.
     *
     * @param subscriber Subscriber to be added.
     */
    void addSubscriber(std::shared_ptr<Observer<nlohmann::json&>> subscriber)
    {
        m_subject.attach(subscriber);
    }

    /**
     * @brief Removes subscriber.
     *
     * @param observerId Observer ID.
     */
    void removeSubscriber(const std::string& observerId)
    {
        m_subject.detach(observerId);
    }

    /**
     * @brief Get updater configuration.
     *
     * @return nlohmann::json Configuration.
     */
    nlohmann::json getUpdaterConfiguration() const
    {
        return m_configuration.at("updater");
    }

    /**
     * @brief Get exclusions.
     *
     * @return nlohmann::json Exclusions configuration.
     */
    nlohmann::json getExclusions() const
    {
        return m_configuration.at("exclusions");
    }

    /**
     * @brief Get indexer connector configuration.
     *
     * @return nlohmann::json Connector configuration.
     */
    nlohmann::json getIndexerConfiguration() const
    {
        return m_configuration.at("indexer");
    }

    /**
     * @brief Get vulnerability detection configuration.
     *
     * @return nlohmann::json vulnerability-detection configuration.
     */
    nlohmann::json getVulnerabilityDetection() const
    {
        return m_configuration.at("vulnerability-detection");
    }

    /**
     * @brief Get vulnerability detection status.
     *
     * @return true if enabled or false if not.
     */
    bool isVulnerabilityDetectionEnabled() const
    {
        return m_vulDetectEnabled;
    }

    /**
     * @brief Get indexer status.
     *
     * @return true if enabled or false if not.
     */
    bool isIndexerEnabled() const
    {
        return m_indexerEnabled;
    }

    /**
     * @brief Get feed url.
     *
     * @return std::string feedUrl.
     */
    std::string getFeedUrl() const
    {
        return m_urlFeed;
    }

    /**
     * @brief Get feed url.
     *
     * @return std::string feedUrl.
     */
    long getFeedUpdateTime() const
    {
        return m_feedUpdateTime;
    }

    /**
     * @brief Get feed url.
     *
     * @return std::string feedUrl.
     */
    std::unordered_set<std::string> getHostList() const
    {
        return m_hostList;
    }

    /**
     * @brief Get certificate authorities.
     *
     * @return std::unordered_set caList.
     */
    std::unordered_set<std::string> getCAList() const
    {
        return m_caList;
    }

    /**
     * @brief Get username.
     *
     * @return std::string username.
     */
    std::string getUsername() const
    {
        return m_username;
    }

    /**
     * @brief Get password.
     *
     * @return std::string password.
     */
    std::string getPassword() const
    {
        return m_password;
    }

    /**
     * @brief Get certificate.
     *
     * @return std::string certificate.
     */
    std::string getCertificate() const
    {
        return m_certificate;
    }

    /**
     * @brief Get key.
     *
     * @return std::string key.
     */
    std::string getKey() const
    {
        return m_key;
    }

    /**
     * @brief Get apikey.
     *
     * @return std::string apikey.
     */
    std::string getApikey() const
    {
        return m_apikey;
    }
};

#endif //_POLICY_MANAGER_HPP
