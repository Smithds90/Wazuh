/*
 * Wazuh PolicyManager
 * Copyright (C) 2015, Wazuh Inc.
 * September 8, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */
#include "policyManager_test.h"

void PolicyManagerTest::SetUp()
{
    m_policyManager = std::make_unique<PolicyManager>();
};

void PolicyManagerTest::TearDown() {};

TEST_F(PolicyManagerTest, validConfigurationVulnerabilityDetection)
{
    const auto& configJson {nlohmann::json::parse(R"({
    "enabled": "yes",
    "index-status": "yes",
    "feed-update-interval": "60m",
    "offline-url": "file:///var/algo.tar.gz"
})")};
    EXPECT_NO_THROW(m_policyManager->validateAndConfigureVulnerabilityDetection(configJson));

    EXPECT_TRUE(m_policyManager->isVulnerabilityDetectionEnabled());
    EXPECT_TRUE(m_policyManager->isIndexerEnabled());

    EXPECT_STREQ(m_policyManager->getFeedUrl().c_str(), "file:///var/algo.tar.gz");
    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3600);
}

TEST_F(PolicyManagerTest, validConfigurationIndexer)
{
    const auto& configJson {nlohmann::json::parse(R"({
    "enabled": "yes",
    "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
    "username": "ImGroot",
    "password": "MoreSecurePassword123",
    "api_key": "ABC123",
    "ssl": {
      "certificate_authorities": ["/var/ossec/"],
      "certificate": "cert",
      "key": "ItsASecret!"
    }
})")};
    EXPECT_NO_THROW(m_policyManager->validateAndConfigureIndexer(configJson));

    EXPECT_TRUE(m_policyManager->isIndexerEnabled());

    EXPECT_STREQ(m_policyManager->getUsername().c_str(), "ImGroot");
    EXPECT_STREQ(m_policyManager->getPassword().c_str(), "MoreSecurePassword123");
    EXPECT_STREQ(m_policyManager->getApikey().c_str(), "ABC123");

    EXPECT_EQ(m_policyManager->getCAList().count("/var/ossec/"), 1);

    EXPECT_STREQ(m_policyManager->getCertificate().c_str(), "cert");
    EXPECT_STREQ(m_policyManager->getKey().c_str(), "ItsASecret!");
}

TEST_F(PolicyManagerTest, invalidFieldVulnerabilityDetection)
{
    const auto& configJson {nlohmann::json::parse(R"({
    "enable": "yes",
    "index-status": "yes",
    "feed-update-interval": "60m",
    "offline-url": "file:///var/algo.tar.gz"
})")};
    EXPECT_THROW(m_policyManager->validateAndConfigureVulnerabilityDetection(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidFieldIndexer)
{
    const auto& configJson {nlohmann::json::parse(R"({
    "enabled": "yes",
    "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
    "username": "user",
    "password": "pwd",
    "api_key": "",
    "ssl": {
      "certificate_authorities": ["/var/ossec/"],
      "certificate": "cert",
      "key": ""
    }
})")};
    EXPECT_THROW(m_policyManager->validateAndConfigureVulnerabilityDetection(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidFieldEnabled)
{
    const auto& configJson {nlohmann::json::parse(R"({
    "enabled": "invalidValue",
    "index-status": "yes",
    "feed-update-interval": "60m",
    "offline-url": "file:///var/algo.tar.gz"
    })")};
    EXPECT_THROW(m_policyManager->validateAndConfigureVulnerabilityDetection(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfiguration)
{
    const auto& configJson {nlohmann::json::parse(R"({
  "vulnerability-detection": {
    "enabled": "yes",
    "index-status": "yes",
    "feed-update-interval": "60m",
    "offline-url": "file:///var/algo.tar.gz"
  },
  "indexer": {
    "enabled": "no",
    "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
    "username": "user",
    "password": "pwd",
    "api_key": "",
    "ssl": {
      "certificate_authorities": ["/var/ossec/"],
      "certificate": "cert",
      "key": ""
    }
  }
})")};
    m_policyManager->loadConfiguration(configJson);
    EXPECT_THROW(m_policyManager->validateConfiguration(), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfigurationNoIndexer)
{
    // Configuration with missing "indexer" field.
    const auto& configJson {nlohmann::json::parse(R"(
    {
      "vulnerability-detection":
      {
        "dummy": true
      }
    }
  )")};

    ASSERT_NO_THROW(m_policyManager->loadConfiguration(configJson));
    EXPECT_THROW(m_policyManager->validateConfiguration(), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfigurationNoVulnerabilityDetection)
{
    // Configuration with missing "vulnerability-detection" field.
    const auto& configJson {nlohmann::json::parse(R"(
    {
      "indexer":
      {
        "dummy": true
      }
    }
  )")};

    ASSERT_NO_THROW(m_policyManager->loadConfiguration(configJson));
    EXPECT_THROW(m_policyManager->validateConfiguration(), std::runtime_error);
}

TEST_F(PolicyManagerTest, getUpdaterConfiguration)
{
    const auto& configJson {nlohmann::json::parse(R"(
    {
      "indexer":
      {
        "config": "indexer"
      },
      "vulnerability-detection":
      {
        "config": "vulnerability-detection"
      },
      "updater":
      {
        "config": "updater"
      }
    }
  )")};

    ASSERT_NO_THROW(m_policyManager->loadConfiguration(configJson));
    EXPECT_EQ(m_policyManager->getUpdaterConfiguration(), R"({"config":"updater"})"_json);
}

TEST_F(PolicyManagerTest, invalidFieldIndexerSecondScenario)
{
    const auto& configJson {nlohmann::json::parse(R"({
  "vulnerability-detection": {
    "enabled": "yes",
    "index-status": "yes",
    "feed-update-interval": "60m",
    "offline-url": "file:///var/algo.tar.gz"
  },
  "indexer": {
    "enable": "yes",
    "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
    "username": "user",
    "password": "pwd",
    "api_key": "",
    "ssl": {
      "certificate_authorities": ["/var/ossec/"],
      "certificate": "cert",
      "key": ""
    }
  }
})")};
    m_policyManager->loadConfiguration(configJson);
    EXPECT_THROW(m_policyManager->validateConfiguration(), std::runtime_error);
}

TEST_F(PolicyManagerTest, checkValidParameters)
{
    const auto& configJson {nlohmann::json::parse(R"({
  "vulnerability-detection": {
    "enabled": "yes",
    "index-status": "yes",
    "feed-update-interval": "60m",
    "offline-url": "file:///var/algo.tar.gz"
  },
  "indexer": {
    "enabled": "yes",
    "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
    "username": "ImGroot",
    "password": "MoreSecurePassword123",
    "api_key": "ABC123",
    "ssl": {
      "certificate_authorities": ["/var/ossec/"],
      "certificate": "cert",
      "key": "ItsASecret!"
    }
  }
})")};
    m_policyManager->loadConfiguration(configJson);
    EXPECT_NO_THROW(m_policyManager->validateConfiguration());

    EXPECT_TRUE(m_policyManager->isVulnerabilityDetectionEnabled());
    EXPECT_TRUE(m_policyManager->isIndexerEnabled());

    EXPECT_STREQ(m_policyManager->getFeedUrl().c_str(), "file:///var/algo.tar.gz");
    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3600);

    EXPECT_EQ(m_policyManager->getHostList().count("http://10.2.20.2:9200"), 1);
    EXPECT_EQ(m_policyManager->getHostList().count("https://10.2.20.42:9200"), 1);

    EXPECT_STREQ(m_policyManager->getUsername().c_str(), "ImGroot");
    EXPECT_STREQ(m_policyManager->getPassword().c_str(), "MoreSecurePassword123");
    EXPECT_STREQ(m_policyManager->getApikey().c_str(), "ABC123");

    EXPECT_EQ(m_policyManager->getCAList().count("/var/ossec/"), 1);

    EXPECT_STREQ(m_policyManager->getCertificate().c_str(), "cert");
    EXPECT_STREQ(m_policyManager->getKey().c_str(), "ItsASecret!");
}
