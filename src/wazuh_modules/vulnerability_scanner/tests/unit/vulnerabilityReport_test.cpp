/*
 * Wazuh databaseFeedManager
 * Copyright (C) 2015, Wazuh Inc.
 * November 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityReport_test.hpp"
#include "../vulnerabilityReport/vulnerabilityReport.hpp"
#include "socketClient.hpp"
#include "socketServer.hpp"

const std::string TEST_PATH {"/tmp/socket"};
const size_t MAX_RETRIES {1000};

TEST_F(VulnerabilityReportTest, SendFormattedMsg)
{
    const std::string report =
        R"({"vulnerability":{"cve":"CVE-2023-5388","package":{"architecture":"amd64","condition":"Package unfixed","name":"libnss3","source":"nss","version":"2:3.68.2-0ubuntu1.2"},"published":"2023-10-23","rationale":"timing issue in RSA operations","references":["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-5388"],"severity":"Medium","status":"Active","title":"Version of package nss affected by CVE-2023-5388 was updated but it is still vulnerable","type":"PACKAGE"}})";
    std::string expectedStr = "1:[001] (agent) 127.0.0.1->vulnerability-scanner:" + report;

    auto thread = std::thread(
        [&]()
        {
            struct sockaddr_un serverAddr, clientAddr;

            int socketServer = socket(AF_UNIX, SOCK_DGRAM, 0);
            ASSERT_NE(socketServer, -1);

            serverAddr.sun_family = AF_UNIX;
            std::strcpy(serverAddr.sun_path, TEST_PATH.c_str());

            ASSERT_NE(bind(socketServer, (struct sockaddr*)&serverAddr, sizeof(serverAddr)), -1);

            char buffer[1024];
            size_t bytesReceived;
            socklen_t clientSize = sizeof(clientAddr);

            bytesReceived =
                recvfrom(socketServer, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &clientSize);

            ASSERT_NE(bytesReceived, -1);
            buffer[bytesReceived] = '\0';

            EXPECT_STREQ(buffer, expectedStr.c_str());

            close(socketServer);
            std::filesystem::remove(TEST_PATH);
        });

    nlohmann::json reportJson = nlohmann::json::parse(report);

    SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper> socketClient {TEST_PATH};

    // Wait for server.
    struct stat fileStat;
    int statRet;
    size_t attemps = -1;
    do
    {
        ++attemps;
        statRet = stat(TEST_PATH.c_str(), &fileStat);
    } while (statRet != 0 && attemps < MAX_RETRIES);

    socketClient.connect([](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {},
                         SOCK_DGRAM);
    VulnerabilityReport::sendReport(socketClient, reportJson, "001", "127.0.0.1", "agent");

    thread.join();
}

TEST_F(VulnerabilityReportTest, InvalidEncodingValue)
{
    std::string expectedString {"Couldn't send JSON report."};

    auto thread = std::thread(
        [&]()
        {
            struct sockaddr_un serverAddr, clientAddr;

            int socketServer = socket(AF_UNIX, SOCK_DGRAM, 0);
            ASSERT_NE(socketServer, -1);

            serverAddr.sun_family = AF_UNIX;
            std::strcpy(serverAddr.sun_path, TEST_PATH.c_str());

            ASSERT_NE(bind(socketServer, (struct sockaddr*)&serverAddr, sizeof(serverAddr)), -1);

            char buffer[1024];
            size_t bytesReceived;
            socklen_t clientSize = sizeof(clientAddr);

            bytesReceived =
                recvfrom(socketServer, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &clientSize);

            ASSERT_NE(bytesReceived, -1);
            buffer[bytesReceived] = '\0';

            EXPECT_STREQ(buffer, expectedString.c_str());

            close(socketServer);
            std::filesystem::remove(TEST_PATH);
        });

    nlohmann::json reportJson;
    nlohmann::json packageObject;
    packageObject["name"] = "\xAA";
    reportJson["vulnerability"] = packageObject;

    SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper> socketClient {TEST_PATH};

    // Wait for server.
    struct stat fileStat;
    int statRet;
    size_t attemps = -1;
    do
    {
        ++attemps;
        statRet = stat(TEST_PATH.c_str(), &fileStat);
    } while (statRet != 0 || attemps < MAX_RETRIES);

    socketClient.connect([](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {},
                         SOCK_DGRAM);

    try
    {
        VulnerabilityReport::sendReport(socketClient, reportJson, "001", "127.0.0.1", "agent");

        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        send(socketClient.getSocketDescriptor(), e.what(), strlen(e.what()), 0);
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }

    thread.join();
}
