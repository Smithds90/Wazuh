/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "scanOrchestrator_test.hpp"
#include "scanOrchestrator/scanOrchestrator.hpp"
#include <external/nlohmann/json.hpp>
#include <memory>
#include <string>
#include <vector>

/*
 * @brief Log function used by ScanOrchestrator.
 */
// LCOV_EXCL_START
void logFunction(const modules_log_level_t logLevel, const std::string& logMessage)
{
    std::ignore = logLevel;
    std::ignore = logMessage;
}
// LCOV_EXCL_STOP

/*
 * @brief Test instantion of the ScanOrchestrator class.
 */
TEST_F(ScanOrchestratorTest, TestInstantionOfTheScanContextStruct)
{
    // Instantion of the ScanOrchestrator class.
    EXPECT_NO_THROW(std::make_shared<ScanOrchestrator>(logFunction));
}

/*
 * @brief Test run with valid message.
 */
TEST_F(ScanOrchestratorTest, TestRunWithValidMessage)
{
    // TODO: Remove the GTEST_SKIP once the implementation of ScanContext is completed
    GTEST_SKIP();
    std::string agentId {"agentId"};
    std::shared_ptr<IndexerConnector> indexerConnector;

    std::string data {R"({"type":"dbsync_packages"})"};
    std::vector<char> message(50, ' ');
    std::copy(data.begin(), data.end(), message.begin() + 15);

    std::shared_ptr<ScanOrchestrator> scanOrchestrator;

    // Instantion of the ScanOrchestrator class.
    EXPECT_NO_THROW(scanOrchestrator = std::make_shared<ScanOrchestrator>(logFunction));

    // It shouldn't throw an exception because it's already handled
    EXPECT_NO_THROW(scanOrchestrator->run(agentId, message, indexerConnector));
}

/*
 * @brief Test run with invalid message.
 */
TEST_F(ScanOrchestratorTest, TestRunWithInvalidMessage)
{
    // TODO: Remove the GTEST_SKIP once the implementation of ScanContext is completed
    GTEST_SKIP();
    std::string agentId {"agentId"};
    std::shared_ptr<IndexerConnector> indexerConnector;

    std::string data {R"({"type":"invalid"})"};
    std::vector<char> message(50, ' ');
    std::copy(data.begin(), data.end(), message.begin() + 15);

    std::shared_ptr<ScanOrchestrator> scanOrchestrator;

    // Instantion of the ScanOrchestrator class.
    EXPECT_NO_THROW(scanOrchestrator = std::make_shared<ScanOrchestrator>(logFunction));

    // It shouldn't throw an exception because it's already handled
    EXPECT_NO_THROW(scanOrchestrator->run(agentId, message, indexerConnector));
}

/*
 * @brief Test run with empty message.
 */
TEST_F(ScanOrchestratorTest, TestRunWithEmptyMessage)
{
    // TODO: Remove the GTEST_SKIP once the implementation of ScanContext is completed
    GTEST_SKIP();
    std::string agentId {"agentId"};
    std::shared_ptr<IndexerConnector> indexerConnector;

    std::string data {R"({})"};
    std::vector<char> message(50, ' ');
    std::copy(data.begin(), data.end(), message.begin() + 15);

    std::shared_ptr<ScanOrchestrator> scanOrchestrator;

    // Instantion of the ScanOrchestrator class.
    EXPECT_NO_THROW(scanOrchestrator = std::make_shared<ScanOrchestrator>(logFunction));

    // It shouldn't throw an exception because it's already handled
    EXPECT_NO_THROW(scanOrchestrator->run(agentId, message, indexerConnector));
}
