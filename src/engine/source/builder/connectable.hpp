/* Copyright (C) 2015-2021, Wazuh Inc.
 * All rights reserved.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _CONNECTABLE_H
#define _CONNECTABLE_H

#include <set>

#include <fmt/format.h>
#include <rxcpp/rx.hpp>

#include "json.hpp"

namespace builder::internals
{

/**
 * @brief A connectable is a structure which help us build the RXCPP graph when
 * our assets are in the graph.
 *
 * @tparam Observable
 */
template<class Observable>
struct Connectable
{
    // Only if Observable is an observable
    using eventType = typename Observable::source_operator_type::value_type;

    // TODO: Add move semantics
    /**
     * @brief Implements the functionality needed to send trace information
     * outside rxcpp main pipeline, using a subject and a function that sends
     * the messages through said subject.
     *
     */
    struct Tracer
    {
        std::string m_name;
        rxcpp::subjects::subject<std::string> m_sbj;
        rxcpp::observable<std::string> m_out;

        Tracer() = default;

        /**
         * @brief Construct a new Tracer object.
         *
         * @param name name of the asset.
         */
        explicit Tracer(std::string name)
            : m_name {name}
            , m_out {m_sbj.get_observable()}
        {
        }

        /**
         * @brief Return tracer function that logs a message.
         * This function will only send the event if the subject observable has
         * subscribers.
         *
         * @return std::function<void(std::string)>
         */
        auto tracerLogger() const -> std::function<void(std::string)>
        {
            return [name = m_name, s = m_sbj.get_subscriber(), sbj = m_sbj](
                       std::string msg)
            {
                if (sbj.has_observers() && s.is_subscribed())
                {
                    s.on_next(fmt::format("({}) {}", name, msg));
                }
            };
        }

        /**
         * @brief Return tracer function that logs a message and the event as
         * string. This function will only send the event if the subject
         * observable has subscribers.
         *
         * @return std::function<void(std::string, eventType)>
         */
        auto tracerLoggerEvent() const
            -> std::function<void(std::string, eventType)>
        {
            return [name = m_name, s = m_sbj.get_subscriber(), sbj = m_sbj](
                       std::string msg, eventType event)
            {
                if (sbj.has_observers() && s.is_subscribed())
                {
                    s.on_next(
                        fmt::format("({}) {} {}", name, msg, event->str()));
                }
            };
        }
    };

    /**
     * @brief An operation is a function which will generate
     * an observable with the apropriate transformations and filters
     * generated by the asset building process.
     */
    using Op_t = std::function<Observable(const Observable &)>;
    Op_t m_op;

    Tracer m_tracer;

    /**
     * @brief Used to distinguish between connectables. Also for debugging
     * purposes. It is derived from the name of the asset it contains de
     * operation for.
     */
    std::string m_name;

    /**
     * @brief The name of the parents of this connectable, derived directly
     * from the assets definition.
     */
    std::set<std::string> m_parents;

    /**
     * @brief The parents' outputs are this connectable inputs. Each connecatble
     * must merge their parents' output as a single input for this connectable
     * operation.
     */
    std::vector<Observable> m_inputs {};

    /**
     * @brief Construct a new Connectable object from its components.
     *
     * @param n name of the connectable
     * @param p vector of parents names
     * @param o the operation this connectable must do to the input stream.
     */
    Connectable(std::string n, std::vector<std::string> p, Op_t o, Tracer tr)
        : m_op(o)
        , m_name(n)
        , m_parents(p.begin(), p.end())
        , m_tracer {tr}
    {
    }

    /**
     * @brief Construct a new Connectable object just from its name. It will use
     * a default passthough operation which allow us to create nodes whose sole
     * purpose is to facilitate the graph construction.
     *
     * @param n name of the connectable
     */
    Connectable(std::string n)
        : m_name(n)
        , m_tracer {n}
    {
        if (n.find("OUTPUT_") == std::string::npos)
        {
            m_op = [trFnEvt = m_tracer.tracerLoggerEvent()](Observable o)
            {
                return o.tap(
                    [=](auto event)
                    {
                        // TODO: we are assuming event is a shared pointer
                        // We should expect that template event has to_str
                        // method instead
                        trFnEvt(" forwarded: ", event);
                    },
                    [](auto eptr) {},
                    []() {});
            };
        }
        else
        {
            m_op = [trFnEvt = m_tracer.tracerLoggerEvent(),
                    trFn = m_tracer.tracerLogger()](Observable o)
            {
                return o
                    .tap(
                        [=](auto event)
                        {
                            // TODO: we are assuming event is a shared pointer
                            // We should expect that template event has to_str
                            // method instead
                            trFnEvt(" got: ", event);
                        },
                        [](auto eptr) {},
                        []() {})
                    .distinct_until_changed()
                    .tap([=](auto event) { trFn(" sent event"); },
                         [](auto eptr) {},
                         []() {});
            };
        }
    };

    /**
     * @brief Default constructor, needed my map
     *
     */
    Connectable()
        : Connectable {"not_initialized"}
    {
    }

    /**
     * @brief Adds an input stream to this connectable
     *
     * @param obs input stream
     */
    void addInput(Observable obs)
    {
        m_inputs.push_back(obs);
    }
    /**
     * @brief Connects an input stream with the operation of this
     * connectable and returns an observable with the operation already
     * attached.
     *
     * @param input
     * @return Observable
     */
    Observable connect(const Observable &input)
    {
        return m_op(input);
    }

    /**
     * @brief Merge all inputs of this node into a single stream and return
     * an observable with the operation already attached.
     *
     * @return Observable
     */
    Observable connect()
    {
        if (m_inputs.size() > 1)
        {
            return m_op(rxcpp::observable<>::iterate(m_inputs).merge());
        }
        return m_op(m_inputs[0]);
    }

    // TODO: may be no longer needed
    /**
     * @brief Operators defined so Connectables can be stored on maps and sets as
     * keys.
     *
     */

    friend inline bool operator<(const Connectable &lhs, const Connectable &rhs)
    {
        return lhs.m_name < rhs.m_name;
    }

    friend inline std::ostream &operator<<(std::ostream &os,
                                           const Connectable &rhs)
    {
        os << rhs.m_name;
        return os;
    }

    friend inline bool operator!=(const Connectable &l, const Connectable &r)
    {
        return l.m_name != r.m_name;
    }

    friend inline bool operator==(const Connectable &l, const Connectable &r)
    {
        return l.m_name == r.m_name;
    }
};
} // namespace builder::internals
#endif // _CONNECTABLE_H
