#ifndef _API_TEST_SESSION_HPP
#define _API_TEST_SESSION_HPP

#include <condition_variable>
#include <ctime>
#include <memory>
#include <mutex>
#include <string>
#include <unordered_map>
#include <vector>

namespace api::sessionManager
{

/**
 * @brief Structure for synchronizing and storing output trace data.
 *
 * This struct is used to synchronize and store data related to output trace and session description.
 * It provides synchronization mechanisms to ensure that the data is ready for safe access and updates.
 */
struct OutputTraceDataSync
{
    std::string asset;  ///< Name of the asset associated with the trace and output data.

    std::string output; ///< Output generated by the asset's events in string format.

    /**
     * @brief History of events and conditions related to the asset.
     *
     * Each element in the vector is a pair of strings representing an event and its associated condition.
     * It is used to maintain a history of events and conditions related to the asset.
     */
    std::vector<std::pair<std::string, std::string>> history;

    /**
     * @brief Trace map that associates each asset with its set of traces.
     *
     * The map stores output traces associated with each asset in the form of a vector of shared pointers to
     * stringstream. Each stringstream contains an output trace of the asset.
     */
    std::unordered_map<std::string, std::vector<std::shared_ptr<std::stringstream>>> trace;

    // Synchronization
    std::mutex sync;                 ///< Mutex for synchronizing access to the data in this struct.
    std::condition_variable cv_data; ///< Condition variable for signaling data readiness.
    bool dataIsReady;                ///< Flag indicating if the data is ready for access.
};

/**
 * @brief Session class.
 *
 */
class Session
{
public:
    Session(const std::string& sessionName,
            const std::string& policyName,
            const std::string& filterName,
            const std::string& routeName,
            const uint32_t sessionID,
            const uint32_t lifespan,
            const std::string& description,
            const std::time_t creationDate)
        : m_creationDate(creationDate)
        , m_description(description)
        , m_filterName(filterName)
        , m_lifespan(lifespan)
        , m_policyName(policyName)
        , m_routeName(routeName)
        , m_sessionID(sessionID)
        , m_sessionName(sessionName)
    {
        m_spOutputTraceDataSync = std::make_shared<OutputTraceDataSync>();
        m_spOutputTraceDataSync->asset = policyName;
        m_spOutputTraceDataSync->dataIsReady = false;
    }

    /**
     * @brief Get the session description.
     *
     * @return std::string
     */
    std::string getDescription() const { return m_description; };

    /**
     * @brief Get the filter name.
     *
     * @return std::string
     */
    std::string getFilterName() const { return m_filterName; };

    /**
     * @brief Get the policy name.
     *
     * @return std::string
     */
    std::string getPolicyName() const { return m_policyName; };

    /**
     * @brief Get the route name.
     *
     * @return std::string
     */
    std::string getRouteName() const { return m_routeName; };

    /**
     * @brief Get the session ID.
     *
     * @return uint32_t
     */
    uint32_t getSessionID() const { return m_sessionID; };

    /**
     * @brief Get the session name.
     *
     * @return std::string
     */
    std::string getSessionName() const { return m_sessionName; };

    /**
     * @brief Get the session creation date.
     *
     * @todo Consider using modern C++ features like std::chrono instead of std::time_t.
     *
     * @return std::time_t
     */
    std::time_t getCreationDate() const { return m_creationDate; };

    /**
     * @brief Get the session lifespan.
     *
     * @return uint32_t
     */
    uint32_t getLifespan() const { return m_lifespan; };

    /**
     * @brief Get the Data Sync object
     *
     * @return std::shared_ptr<OutputTraceDataSync>
     */
    std::shared_ptr<OutputTraceDataSync> getDataSync() const { return m_spOutputTraceDataSync; };

private:
    const std::string m_description;  ///< Session description.
    const std::string m_filterName;   ///< Filter name.
    const std::string m_policyName;   ///< Policy name.
    const std::string m_routeName;    ///< Route name.
    const std::string m_sessionName;  ///< Session name.
    const std::time_t m_creationDate; ///< Session creation date.
    const uint32_t m_lifespan;        ///< Session m_lifespan in minutes. 0 means no expiration.
    const uint32_t m_sessionID;       ///< Session ID.
    std::shared_ptr<OutputTraceDataSync> m_spOutputTraceDataSync; ///< Output and trace data.
};

} // namespace api::sessionManager

#endif // _API_TEST_SESSION_HPP
